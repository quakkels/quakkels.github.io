<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Practices on Quakkels.com</title>
    <link>http://quakkels.com/tags/practices/index.xml</link>
    <description>Recent content in Practices on Quakkels.com</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://quakkels.com/tags/practices/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Don&#39;t take Frameworks for Granted</title>
      <link>http://quakkels.com/posts/dont-take-frameworks-for-granted/</link>
      <pubDate>Sat, 28 Jan 2017 07:41:18 -0600</pubDate>
      
      <guid>http://quakkels.com/posts/dont-take-frameworks-for-granted/</guid>
      <description>&lt;p&gt;Frameworks can help jump-start productivity on projects. But be careful.
Relying too much on frameworks could also limit yourself in the long run.&lt;/p&gt;

&lt;p&gt;Whenever the opportunity presents itself, programmers should carefully consider
whether using a framework is beneficial. It may provide immediate benefits, but
there should be no magic happening that isn&amp;rsquo;t understood by the programmer.&lt;/p&gt;

&lt;p&gt;Years ago, I learned how to make websites with C#. I had help from many books,
tutorials, and co-workers. With those resources I used the ASP.NET MVC 1
framework to build websites in a new way. However, while building my sample MVC
sites, the code I wrote was there just because that&amp;rsquo;s how it was written in a
tutorial somewhere. At the time, I had very little understanding of how the
internals worked. I didn&amp;rsquo;t understand how routing worked, or how reflection
worked, or how factories fit in, or anything about what a view engine did, or
model binding. It was all just magic that I accepted and had faith in.&lt;/p&gt;

&lt;p&gt;I was able to build a working website with C# and ASP.NET MVC, and I did it
fairly quickly. It was certainly done faster than it would have been without the
framework. This fact can&amp;rsquo;t be ignored. Learning a technology while achieving
results is important for any beginner. The experience of finishing something
is valuable for the sense of accomplishment and for the motivation to keep
going. But, it&amp;rsquo;s important to understand that once a project is finished, the
learning should not stop. Understanding the building blocks of any framework is
the foundation for every solid programmer.&lt;/p&gt;

&lt;p&gt;In my case, it was very important that I continued to build up my foundation of
understanding. That&amp;rsquo;s because projects in the real world don&amp;rsquo;t just end like
side projects could. They live on and they evolve. Real projects keep receiving
feature requests. New requirements will appear. Technology will change.
Eventually, the chosen framework might lose support, or might not keep up with
requirements. When that happens, knowledge of how the framework functions is
imperative. Without that knowledge, programmers are at the mercy of tutorial
writers and the framework creators. But with a knowledgeable foundation,
programmers are equipped to continue building and shipping their projects.&lt;/p&gt;

&lt;p&gt;The bottom line is this: frameworks can be wielded much more effectively
&lt;em&gt;after&lt;/em&gt; the programmer understands enough of the language and design concepts
so that the framework&amp;rsquo;s behavior isn&amp;rsquo;t magic anymore. Programmers equipped with
such understanding will know where to look for seams in the execution pipeline,
and they will be able to add customizations where appropriate.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Maintaining Your Vision</title>
      <link>http://quakkels.com/posts/maintaining-your-vision/</link>
      <pubDate>Mon, 03 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://quakkels.com/posts/maintaining-your-vision/</guid>
      <description>&lt;p&gt;Programmers are often creators. Being a creator takes vision. Vision to see the destination, and vision to see the course. The destination could be learning a new language or technology stack. The destination could be a product to be released to customers. It could be something done for personal edification. The course is determined by taking that larger goal and breaking it down to manageable steps.&lt;/p&gt;

&lt;p&gt;The trick for successfully creating something, is to maintain that vision. But often the vision becomes lost and projects end up stalled or abandoned entirely.&lt;/p&gt;

&lt;p&gt;Patience in our work as programmers may be one of the most underrated skills a programmer could possess. There have been many articles &lt;sup&gt;(&lt;a href=&#34;http://blogoscoped.com/archive/2005-08-24-n14.html&#34;&gt;1&lt;/a&gt;, &lt;a href=&#34;http://www.jerf.org/programming/lazyProgrammersGuide.html&#34;&gt;2&lt;/a&gt;)&lt;/sup&gt; written about the benefits of being a so-called &amp;ldquo;lazy programmer&amp;rdquo; which can lead to the benefits of automating common tasks. Though, the role that patience plays in persevering in a project is something that seems to get lost in the conversation.&lt;/p&gt;

&lt;p&gt;Patience is important on many levels, but two come to mind in particular. There&amp;rsquo;s the project level, and then there&amp;rsquo;s the module level.&lt;/p&gt;

&lt;p&gt;Patience is useful on the project level when you can see your ultimate goal, but there are barriers to getting it done. A type of project that I frequently undertake is learning a new programming language. It often presents itself as &amp;ldquo;I want to write X application using X language.&amp;rdquo; I can see the application in my mind. The barrier to finishing the application is the syntax and ecosystem of the language I intend to learn. Of course, right? The point of the whole project is learn those new things. This is when impatience can be a project killer because shortcuts get taken. The original goal was twofold: 1) language and 2) application. Impatience can shift that goal into becoming a singular goal based on an exciting app, rather than the dual target of learning and also building. Project level impatience is what usually causes my personal projects to languish.&lt;/p&gt;

&lt;p&gt;What I&amp;rsquo;ll call module level impatience is the kind of thing that rears its head when you&amp;rsquo;re eyeballs deep in code. The ultimate function of the feature being written becomes the focus, and the voice of impatience starts nagging about taking shortcuts to get to the finish line faster. This impatience clouds the reasoning about the individual pieces of the feature being implemented. It is the enemy of clean and maintainable code.&lt;/p&gt;

&lt;p&gt;The truth is that when we code with an impatient mindset, then the results will suffer. Patience is required to maintain the project&amp;rsquo;s vision.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>