<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Practices on Quakkels.com</title>
    <link>http://quakkels.com/tags/practices/index.xml</link>
    <description>Recent content in Practices on Quakkels.com</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://quakkels.com/tags/practices/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Identify Valid Standards</title>
      <link>http://quakkels.com/posts/identify-valid-standards/</link>
      <pubDate>Thu, 16 Feb 2017 07:26:36 -0600</pubDate>
      
      <guid>http://quakkels.com/posts/identify-valid-standards/</guid>
      <description>

&lt;p&gt;I can&amp;rsquo;t tell you how many times I&amp;rsquo;ve been in software planning meetings when an engineer addressed the team and claimed that we should use {insert technology here} because it&amp;rsquo;s the &amp;ldquo;Industry Standard.&amp;rdquo; I also can&amp;rsquo;t tell you how many times I&amp;rsquo;ve done the same thing. I&amp;rsquo;ve gone into my boss&amp;rsquo;s office and claimed that we should use a particular stack or technology because it&amp;rsquo;s an &amp;ldquo;industry standard.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;This reasoning is attractive because on the surface it seems valid. I mean, it
must be an industry standard for a reason. Right? We&amp;rsquo;d be silly not to use it
as well. Doesn&amp;rsquo;t that make sense?&lt;/p&gt;

&lt;h2 id=&#34;hype-mentality&#34;&gt;Hype mentality&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&amp;ldquo;Hey coach, I think we should run screens because it&amp;rsquo;s the league standard.
Everyone runs screens. If we want our team to win, we need to be
running screens all the time.&amp;rdquo;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Choosing technology based on popularity is easy. As programmers, it&amp;rsquo;s important
to us to stay current and not let any good technology get past us. As a result,
there are many ways that we can be influenced; industry publications, surveys,
Blogs, Twitter, Reddit, even chatter in the break room. However, we need to be
careful to weigh arguments based on technical merit and not succumb to the
subliminal effects of hype.&lt;/p&gt;

&lt;h2 id=&#34;hair-on-fire-mentality&#34;&gt;Hair-on-fire mentality&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&amp;ldquo;Hey coach, I think we should stop using back-shoulder passes down the field. We should remove them from our playbook entirely. Last time we ran a back-shoulder pass, we went three and out.&amp;rdquo;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;When bugs that appear in staging (or even worse&amp;#151;production)  people will look for a root cause for why it occurred. This is good to do and it&amp;rsquo;s definitely the correct response. But those investigating should be sure to focus on the root cause of the bug. If they find a bug in code that relies on a third party library, there is a temptation to question the decisions of the team that added the library. This is usually due to a misplaced concern that the bug is a result of using a less popular (or non-standard) library. Instead, the investigation should focus on things like logic errors, syntax errors, and whether behavior is unit tested.&lt;/p&gt;

&lt;p&gt;Sweeping rules dictating which libraries engineering teams must use are not the answer. Such a reaction result in standards that halt progress, stifle problem solving, and impede innovation.&lt;/p&gt;

&lt;h2 id=&#34;how-standards-help&#34;&gt;How standards help&lt;/h2&gt;

&lt;p&gt;When programming systems, standards should exist around the parts that need ‘glue’. Anytime there are two applications that need to talk to each other, they should follow a contract to ease communication between them. Examples of these kinds of standards include specifications for protocols such as HTTP, SAML, and OAuth.&lt;/p&gt;

&lt;p&gt;Another area that benefits from industry standards is when describing languages. There must be a standard for what an &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; represents in HTML, and for how a CSS rule such as &lt;code&gt;h1 { color: red; }&lt;/code&gt; affects it. I wouldn&amp;rsquo;t be very productive in a language if when I wrote &lt;code&gt;string&lt;/code&gt; it would treat it like a &lt;code&gt;float&lt;/code&gt;. So having a language standard that defines the expected behavior of syntax and types is very helpful.&lt;/p&gt;

&lt;p&gt;The key to these standards is that they are &lt;em&gt;defining expected behavior for a given tool&lt;/em&gt;. These standards do not dictate which tool to use.&lt;/p&gt;

&lt;h2 id=&#34;picking-the-right-tool-for-a-job&#34;&gt;Picking the right tool for a job&lt;/h2&gt;

&lt;p&gt;Some may claim that one software framework or language is an “industry standard”. Often, this is a result of the person seeing it used by others or featured in articles. So, they conclude that they should use it on every project. If there is even a vague similarity between their current project and the tool’s stated goals, then some people assume they’ve found the best tool for their job. More should be considered when choosing tools.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Good reasons to use a tool:&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;It is stable&lt;/li&gt;
&lt;li&gt;It does what we need&lt;/li&gt;
&lt;li&gt;It is well supported&lt;/li&gt;
&lt;li&gt;Ease of use&lt;/li&gt;
&lt;li&gt;Compatible with existing system&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Bad reasons to use a tool:&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;It&amp;rsquo;s popular&lt;/li&gt;
&lt;li&gt;It&amp;rsquo;s new&lt;/li&gt;
&lt;li&gt;It&amp;rsquo;s been trending on Blogs and industry news sources.&lt;/li&gt;
&lt;li&gt;The current tool is boring. We could use a change.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;don-t-flippantly-swing-the-industry-standard-club&#34;&gt;Don’t flippantly swing the “Industry Standard” club&lt;/h2&gt;

&lt;p&gt;Promoting a tool by claiming that it&amp;rsquo;s an industry standard, rather than because it adheres to standards, is a mistake. There is a key difference between adhering to standards and being a standard. Industry standards are most effective when describing protocols and language behavior. We should select our tools based on how well they adhere to standards.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Don&#39;t Take Frameworks for Granted</title>
      <link>http://quakkels.com/posts/dont-take-frameworks-for-granted/</link>
      <pubDate>Sat, 28 Jan 2017 07:41:18 -0600</pubDate>
      
      <guid>http://quakkels.com/posts/dont-take-frameworks-for-granted/</guid>
      <description>&lt;p&gt;Frameworks can help jump-start productivity on projects. But be careful.
Relying too much on frameworks could also limit yourself in the long run.&lt;/p&gt;

&lt;p&gt;Whenever the opportunity presents itself, programmers should carefully consider
whether using a framework is beneficial. It may provide immediate benefits, but
there should be no magic happening that isn&amp;rsquo;t understood by the programmer.&lt;/p&gt;

&lt;p&gt;Years ago, I learned how to make websites with C#. I had help from many books,
tutorials, and co-workers. With those resources I used the ASP.NET MVC 1
framework to build websites in a new way. However, while building my sample MVC
sites, the code I wrote was there just because that&amp;rsquo;s how it was written in a
tutorial somewhere. At the time, I had very little understanding of how the
internals worked. I didn&amp;rsquo;t understand how routing worked, or how reflection
worked, or how factories fit in, or anything about what a view engine did, or
model binding. It was all just magic that I accepted and had faith in.&lt;/p&gt;

&lt;p&gt;I was able to build a working website with C# and ASP.NET MVC, and I did it
fairly quickly. It was certainly done faster than it would have been without the
framework. This fact can&amp;rsquo;t be ignored. Learning a technology while achieving
results is important for any beginner. The experience of finishing something
is valuable for the sense of accomplishment and for the motivation to keep
going. But, it&amp;rsquo;s important to understand that once a project is finished, the
learning should not stop. Understanding the building blocks of any framework is
the foundation for every solid programmer.&lt;/p&gt;

&lt;p&gt;In my case, it was very important that I continued to build up my foundation of
understanding. That&amp;rsquo;s because projects in the real world don&amp;rsquo;t just end like
side projects could. They live on and they evolve. Real projects keep receiving
feature requests. New requirements will appear. Technology will change.
Eventually, the chosen framework might lose support, or might not keep up with
requirements. When that happens, knowledge of how the framework functions is
imperative. Without that knowledge, programmers are at the mercy of tutorial
writers and the framework creators. But with a knowledgeable foundation,
programmers are equipped to continue building and shipping their projects.&lt;/p&gt;

&lt;p&gt;The bottom line is this: frameworks can be wielded much more effectively
&lt;em&gt;after&lt;/em&gt; the programmer understands enough of the language and design concepts
so that the framework&amp;rsquo;s behavior isn&amp;rsquo;t magic anymore. Programmers equipped with
such understanding will know where to look for seams in the execution pipeline,
and they will be able to add customizations where appropriate.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Maintaining Your Vision</title>
      <link>http://quakkels.com/posts/maintaining-your-vision/</link>
      <pubDate>Mon, 03 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://quakkels.com/posts/maintaining-your-vision/</guid>
      <description>&lt;p&gt;Programmers are often creators. Being a creator takes vision. Vision to see the destination, and vision to see the course. The destination could be learning a new language or technology stack. The destination could be a product to be released to customers. It could be something done for personal edification. The course is determined by taking that larger goal and breaking it down to manageable steps.&lt;/p&gt;

&lt;p&gt;The trick for successfully creating something, is to maintain that vision. But often the vision becomes lost and projects end up stalled or abandoned entirely.&lt;/p&gt;

&lt;p&gt;Patience in our work as programmers may be one of the most underrated skills a programmer could possess. There have been many articles &lt;sup&gt;(&lt;a href=&#34;http://blogoscoped.com/archive/2005-08-24-n14.html&#34;&gt;1&lt;/a&gt;, &lt;a href=&#34;http://www.jerf.org/programming/lazyProgrammersGuide.html&#34;&gt;2&lt;/a&gt;)&lt;/sup&gt; written about the benefits of being a so-called &amp;ldquo;lazy programmer&amp;rdquo; which can lead to the benefits of automating common tasks. Though, the role that patience plays in persevering in a project is something that seems to get lost in the conversation.&lt;/p&gt;

&lt;p&gt;Patience is important on many levels, but two come to mind in particular. There&amp;rsquo;s the project level, and then there&amp;rsquo;s the module level.&lt;/p&gt;

&lt;p&gt;Patience is useful on the project level when you can see your ultimate goal, but there are barriers to getting it done. A type of project that I frequently undertake is learning a new programming language. It often presents itself as &amp;ldquo;I want to write X application using X language.&amp;rdquo; I can see the application in my mind. The barrier to finishing the application is the syntax and ecosystem of the language I intend to learn. Of course, right? The point of the whole project is learn those new things. This is when impatience can be a project killer because shortcuts get taken. The original goal was twofold: 1) language and 2) application. Impatience can shift that goal into becoming a singular goal based on an exciting app, rather than the dual target of learning and also building. Project level impatience is what usually causes my personal projects to languish.&lt;/p&gt;

&lt;p&gt;What I&amp;rsquo;ll call module level impatience is the kind of thing that rears its head when you&amp;rsquo;re eyeballs deep in code. The ultimate function of the feature being written becomes the focus, and the voice of impatience starts nagging about taking shortcuts to get to the finish line faster. This impatience clouds the reasoning about the individual pieces of the feature being implemented. It is the enemy of clean and maintainable code.&lt;/p&gt;

&lt;p&gt;The truth is that when we code with an impatient mindset, then the results will suffer. Patience is required to maintain the project&amp;rsquo;s vision.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>